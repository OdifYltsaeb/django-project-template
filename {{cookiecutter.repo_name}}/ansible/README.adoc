= Ansible Deployments

Contents:

* <<ansible-deployments,Ansible Deployments>>
* <<tldr,TL;DR>>
* <<benefits,Benefits>>
* <<installing-ansible,Installing ansible>>
* <<deployment,Deployment>>
** <<server-setup,Server setup>>
** <<incremental-deploy,Incremental deploy>>
** <<deploying-a-different-version,Deploying a different version>>
** <<the-first-deployment,The first deployment>>
** <<configuring-the-environment,Configuring the environment>>
{%- if cookiecutter.use_auto_deploy == YES %}
* link:./roles/autodeploy/README.md[Automated deployments]
{%- endif %}
* <<download-server-state,Download server state>>

== TL;DR

The command to deploy the project (change the `limit` arg to `live` if you want to deploy to live servers):

[source,bash]
----
poetry run ansible-playbook --limit test deploy.yml

----

see more details in <<incremental-deploy,Incremental deploy>>.

== Benefits

https://docs.ansible.com/ansible/latest/index.html[Ansible], as a configuration &amp; automation framework, provides
fully automated deployments with no user interference on the server host. So all tasks only need to be described
in the configuration, and run on a local machine, thus there is guarantee that no human error would creep in, and that
all hosts managed by the same `ansible` configuration are configured in a consistent fashion.

== Installing ansible

The `ansible` installation is managed by the https://python-poetry.org/docs/[Poetry] tool, which is a Python package manager.

To install `Poetry` on Linux/OS X, run the following command:

[source,bash]
----
curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python
----

A complete installation guide for `Poetry` is available here: https://python-poetry.org/docs/#installation .

After `Poetry` is installed, run (in the `.ansible` directory):

[source,bash]
----
poetry install
----

* this will install `ansible` and other dependencies.

With `Poetry` and `ansible` installed, all `ansible` commands can be executed like:

[source,bash]
----
poetry run ansible-playbook --version
----

or within a subshell started by

[source,bash]
----
poetry shell
Spawning shell within /home/user/.cache/pypoetry/virtualenvs/{{ cookiecutter.repo_name }}-ansible-Yf1XQtRW-py3.6 ...
({{ cookiecutter.repo_name }}-ansible-Yf1XQtRW-py3.6) user@host:.ansible $
----

in which case you don't need to prefix the commands with `poetry run`. This mode of operation is assumed below
throughout the document.

== Deployment

=== Server setup

Your server needs to have https://docs.docker.com/engine/installation/[Docker Engine]
as well as https://docs.docker.com/compose/[Docker Compose] installed.

We also assume that you have Nginx and Postgres (version 10 by default) running in Docker containers and reachable via
'private' network. We also make a few assumptions regards directories that will be used as volumes for static assets,
etc. You can find these paths in link:../docker-compose.production.yml[docker-compose.production.yml].

{%- if cookiecutter.build_in_ci == YES %}

==== Enable registry access for server

This project is deployed with docker images. The images themselves are built in Gitlab CI. To
be able to deploy the code to the cloud the target server must be able to pull images from registry.gitlab.com.

. Navigate to repository settings of the project in gitlab
** {{ cookiecutter.gitlab_repo_url }}/-/settings/repository/
. Expand `Deploy tokens`
. Add a deploy token if it does not exist already for the server. Set the name to server name and use
the project name for username. Under permissions make sure to only enable `read_registry`.
. Add the deploy token value to the host specific vault file under `registry_token` variable.
. Now you can run the ansible stack to set up the docker authentication

*Note:* If `docker login` times out then check if your server has `golang-docker-credential-helpers` installed.
 This helper requires X-Server configuration but this fails when it is not installed (which is usually the case within servers).
 If the helper is installed then either remove it or configure a headless helper instead. You can remove it with the following command:
 `
      dpkg -r --ignore-depends=golang-docker-credential-helpers golang-docker-credential-helpers
`

*Note:* When you are working directly in the server run the following command to be able to pull images
 from the docker registry:

[source,bash]
----
source /srv/{{ cookiecutter.repo_name }}/registry.sh
----

The script sets the value of DOCKER_CONFIG to a project specific directory to allow using multiple
credentials for the same docker registry host. This is a workaround for the following
https://github.com/moby/moby/issues/37569[issue in docker].

{%- endif %}

=== Incremental deploy

____

NB: If the code has *not been deployed* to the server already follow the instructions in <<the-first-deployment,The first deployment>>.

____

Before deploying code ensure that whatever you want deployed is committed and pushed to the server. After that
you can deploy the project to the server by running `deploy.yml` stack with Ansible. This will:

. Clone &amp; checkout the project into test server (with branch/commit specified in `deployment_version` variable)
. Add some configuration files (nginx, env, etc)
{%- if cookiecutter.build_in_ci == YES %}
. Pull docker images for the project from the registry and restart containers if needed
{%- else -%}
. Build docker images for the project
{%- endif %}
. Run migrations and collectstatic

Run the stack with (against test server):

[source,bash]
----
poetry run ansible-playbook --limit test deploy.yml
----

==== Deploying a different version

To deploy a specific version of code to the server you can use the `force_deploy` variable. To set it use
 ansibles `-e` CLI parameter.

[source,bash]
----
poetry run ansible-playbook --limit test -e "force_deploy=stable" deploy.yml
----

=== The first deployment

* Figure out which server you're going to deploy to.
 We usually have one main test server and one main production server for new project.
* Check link:./inventory[inventory] file. It has two groups - `test` and `live`.
 Ensure that the server you'll use is added to the correct group.
* Add (or update) the `vars.yml` and `vault.yml` files for the server in the link:./host_vars[host_vars] directory.
* When creating the files use link:./host_vars/vars-template.yml[vars-template.yml] and
 link:./host_vars/vault-template.yml[vault-template.yml] as an example.
* If you created the vault file make sure to encrypt it: `ansible-vault encrypt host_vars/&lt;hostname&gt;/vault.yml`
* NB: Vault for production and test should have different password.
* Check django settings (`settings/cloud.py`)
* Add the server's SSH key (`/root/.ssh/id_rsa.pub`) to the project repo settings as deployment key.
* Ensure you've committed and pushed all relevant changes.

{% if cookiecutter.django_media_engine == S3 -%}
{% if cookiecutter.thorgate == YES %}
* Ensure you have sufficient permissions in AWS to create a bucket and assume the terraform role (see manual steps below if not using terraform)
* Look over the terraform definitions
 * ./deploy/terraform/variables.tf Make sure that the region is the closest one to the user of the project.
 * ./deploy/terraform/modules/s3_media
 - Public access is denied by default, if you want it to be possible to access without signed urls, change these settings.
* Set your aws credentials
 * `export AWS_ACCESS_KEY_ID=...`
 * `export AWS_SECRET_ACCESS_KEY=...`
* run `make setup-terraform workspace=WORKSPACE` where WORKSPACE is 'staging', 'production'
* Keep the terminal window open as some of these values should be copied into the ansible variables (secrets belong in the vault).

{% endif %}

{% endif %}{% if cookiecutter.django_media_engine == GCS -%}
1. Create a service account (https://cloud.google.com/docs/authentication/getting-started[Google Getting Started Guide]).
2. Create the key and download your-project-XXXXX.json file.
3. Make sure your service account has access to the bucket and appropriate permissions. (https://cloud.google.com/storage/docs/access-control/using-iam-permissions[Using IAM Permissions]).
4. Put the contents of the key file into ansible variable `django_gs_credentials` as a json string
{% endif %}

Now that the prerequisites are done you can deploy the code with the following command.

____

Replace `ENV` with either `test` or `live` (or the actual hostname of the target server).

____

[source,bash]
----
poetry run ansible-playbook --limit ENV deploy.yml
----

If it worked, you're all done, congrats!

Otherwise, if something else broke, you can in most cases fix it and then just run the
Ansible stack again.

=== Configuring the environment

All the environment variables necessary on the server are located in the
link:./roles/deploy/templates/environment[environment] file, which is installed to `.env`
in the project root. Variables in this file can be
(and some should be) populated from Ansible variables, including vault variables.

All docker containers and `docker-compose` itself use environment variables from the `.env` file.

There is a special ansible target (tag) to update the `.env` file on the server: `env`, e.g.

[source,shell]
----
poetry run ansible-playbook --limit HOST -t env deploy.yml
----

== Download server state

____

*Warning:* Using this playbook deletes the local database so back up `.data/postgresql` directory before if you
 need to preserve your current database.

____

We have a playbook to download the media and database state from a remote server hosting the project. If the media
files in the remote server are using S3 then you must first install https://pypi.org/project/awscli/[aws-cli] locally.
The easiest way to do it is via pip: `sudo pip install awscli`.

Every time before you can use the mirror role you also need to activate virtual env containing ansible.
You can do this via: `poetry shell`

This ensures the permissions of local paths are correct to allow the mirror role to work. Once this is done you
can run the restore role with:

[source,bash]
----
poetry run ansible-playbook -v --limit test mirror.yml
----

To restore only database or media files ansible tags can be used:

[source,bash]
----
poetry run ansible-playbook -v --limit test --tags db mirror.yml  # restores only the database
poetry run ansible-playbook -v --limit test --tags media mirror.yml  # restores only the media files
----

== Create superuser to server

____

*Warning:* This feature only works with Django 3.0 or later.

____

We have a playbook to help user to create superuser to remote server hosting the project.

The role will ask for superuser email to use for creating it. Random password will be generated for you.
You can run the role with:

[source,shell]
----
poetry run ansible-playbook --limit test superuser.yml
----

== Clone server

____

*Warning:* Using this playbook deletes and overwrites the database on target server

____

We have a playbook to copy over one server to another. This is a dangerous operation, do not
try it if you don't know what you're doing, and never target a server that is already used
with it.

[source,bash]
----
ansible-playbook -v --limit target.thorgate.eu -e source_host=source.thorgate.eu clone.yml
----

This will:
* Download database from source server to local dump file
* Download media and private files from source server
* Upload database dump from target server
* Drop database on target server
* Restore database dump on target server
* Upload media files to s3 configured on target server

This operation doesn't require to stop project on source host, however it may still be useful
to stop it when performing live migration to ensure that the DB and media are in consistent state.
